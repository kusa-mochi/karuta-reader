import React, { useEffect, useState } from 'react'
import Head from 'next/head'
import Image from 'next/image'
import { Iceberg, Inter } from '@next/font/google'
import styled from 'styled-components'
import SpeechText, { TTSEngine } from '@/ts-common/SpeechText'

export default function Home() {
  const MainContainer = styled.div`
    font-size: 20px;
  `;
  const CardsContainer = styled.div`
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-items: flex-start;
    align-content: flex-start;
  `;
  const Card = styled.div`
    margin: 4px;
    border: 1px solid #303030;
    border-radius: 8px;
    padding: 8px;
    max-width: 400px;
    max-height: 500px;
  `;
  const CurrentCard = styled.div`
    margin: 4px;
    border: 1px solid #cfa984;
    border-radius: 8px;
    padding: 8px;
    max-width: 400px;
    max-height: 500px;
    background-color: #ffdfbf;
  `;
  const UsedCard = styled.div`
    margin: 4px;
    border: 1px solid #303030;
    border-radius: 8px;
    padding: 8px;
    max-width: 400px;
    max-height: 500px;
    opacity: 0.4;
  `;
  const ReadButtonContainer = styled.div`
    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    justify-content: flex-start;
    align-items: center;
    margin: 4px;
  `;
  const ReadButton = styled.button`
    width: 50%;
    height: 200px;
    font-size: 20px;
  `;
  enum CardState {
    NotReadYet = 0,
    CurrentCard,
    AlreadyRead
  }
  interface CardInfo {
    text: string;
    state: CardState;
  }

  let currentCardIndex: number = -1;
  const [karutaLines, setKarutaLines] = useState<CardInfo[]>([]);
  const [readButtonDisability, setReadButtonDisability] = useState<boolean>(true);

  // karutaLines更新後に実行する処理
  useEffect(() => {
    console.log(karutaLines);
    if (karutaLines.length > 0 && isGameOver()) {
      setReadButtonDisability(true);
      setTimeout(() => SpeechText(TTSEngine.gTTS, "ゲーム終了です", "ja-JP"), 5000);
    } else {
      setReadButtonDisability(false);
    }
  }, [karutaLines]);

  // 0以上max未満の乱数（整数）を1つ返す関数。
  const GetRanddomNumber = (max: number): number => {
    return Math.floor(Math.random() * max);
  }

  const LoadTextFile = (e: any): void => {
    if (e.target.files && e.target.files[0]) {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.readAsText(file);
      reader.onload = e => {
        // かるたデータをクリアする。
        setKarutaLines([]);

        const fileContent: string = reader.result as string;
        let lines = fileContent.split(/\r\n|\n/);
        lines = lines.filter(line => line != "");
        console.log(`length of lines:${lines.length}`);
        setKarutaLines(lines.map(function (line: string): CardInfo {
          return {
            text: line,
            state: CardState.NotReadYet
          }
        }));
      }
    } else {
      console.log("failed to upload a file.");
    }
  };

  // ゲームが終了した場合にtrueを返す関数。
  const isGameOver = (): boolean => {
    const numRemainingCards: number = karutaLines.reduce((sum, cardInfo) => {
      if (cardInfo.state === CardState.NotReadYet) return (sum + 1);
      return sum;
    }, 0);

    return numRemainingCards === 0;
  }

  const ReadOneText = (): void => {
    let cardIndex = -1;
    do {
      cardIndex = GetRanddomNumber(karutaLines.length);
    } while (karutaLines[cardIndex].state !== CardState.NotReadYet);
    currentCardIndex = cardIndex;

    const currentCardText: string = karutaLines[currentCardIndex].text;
    // 直前に読み上げたカードを薄色表示にする。現在のカードを協調表示にする。
    setKarutaLines(karutaLines.map(function (cardInfo: CardInfo): CardInfo {
      if (cardInfo.state === CardState.CurrentCard) {
        return {
          text: cardInfo.text,
          state: CardState.AlreadyRead
        }
      } else if (cardInfo.text === currentCardText) {
        return {
          text: cardInfo.text,
          state: CardState.CurrentCard
        }
      } else {
        return {
          text: cardInfo.text,
          state: cardInfo.state
        }
      }
    }));

    // テキストを読み上げる。
    SpeechText(TTSEngine.gTTS, karutaLines[currentCardIndex].text, 'ja-JP');
  };

  return (
    <>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <MainContainer>
        <input type="file" onChange={LoadTextFile}></input>
        <CardsContainer>
          {karutaLines.map(function (lineInfo) {
            switch (lineInfo.state) {
              case CardState.AlreadyRead:
                return (<UsedCard key={lineInfo.text}>{lineInfo.text}</UsedCard>);
              case CardState.CurrentCard:
                return (<CurrentCard key={lineInfo.text}>{lineInfo.text}</CurrentCard>);
              case CardState.NotReadYet:
                return (<Card key={lineInfo.text}>{lineInfo.text}</Card>);
              default:
                return (<Card key={lineInfo.text}>{lineInfo.text}</Card>);
            }
          })}
        </CardsContainer>
        <ReadButtonContainer>
          <ReadButton onClick={ReadOneText} disabled={readButtonDisability}>読み上げる</ReadButton>
        </ReadButtonContainer>
      </MainContainer>
    </>
  )
}
